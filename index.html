<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Filter Lens</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #ffffff;
      font-family: 'Courier New', 'Consolas', monospace;
      overflow: hidden;
      color: #000;
    }
    
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      background: #fff;
      border: 1px solid #000;
      border-radius: 6px;
      padding: 16px;
      z-index: 10;
      min-width: 260px;
    }
    
    .section {
      margin-bottom: 14px;
      padding-bottom: 14px;
      border-bottom: 1px solid #000;
    }
    
    .section.filter-section {
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    
    .section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    
    .label {
      font-size: 11px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
      display: block;
    }
    
    #fileInput {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #000;
      background: #fff;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      cursor: pointer;
    }
    
    .filter-buttons {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    
    .filter-btn {
      width: 24px;
      height: 24px;
      border: 1px solid #000;
      border-radius: 50%;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      padding: 0;
      overflow: hidden;
    }
    
    .filter-btn img {
      width: 12px;
      height: 12px;
      display: block;
      filter: none;
      transition: filter 0.2s;
    }
    
    .filter-btn:hover {
      background: #f0f0f0;
    }
    
    .filter-btn.active {
      background: #000;
    }
    
    .filter-btn.active img {
      filter: invert(1);
    }
    
    .slider-container {
      position: relative;
      padding: 0;
    }
    
    .slider-label-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 11px;
    }
    
    .slider-value {
      font-weight: bold;
    }
    
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 1px;
      background: #000;
      outline: none;
      margin: 0;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #000;
      cursor: pointer;
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #000;
      cursor: pointer;
      border: none;
    }
    
    canvas {
      display: block;
      cursor: none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div class="section">
      <span class="label">Image</span>
      <input type="file" id="fileInput" accept="image/*" />
    </div>

    <div class="section filter-section">
      <span class="label" style="margin: 0;">Filter</span>
      <div class="filter-buttons">
        <button class="filter-btn active" data-filter="stipple">
          <img src="01.svg" alt="Filter 1">
        </button>
        <button class="filter-btn" data-filter="sketch">
          <img src="02.svg" alt="Filter 2">
        </button>
        <button class="filter-btn" data-filter="dither">
          <img src="03.svg" alt="Filter 3">
        </button>
      </div>
    </div>

    <div class="section">
      <div class="slider-container">
        <div class="slider-label-row">
          <span class="label" style="margin: 0;">Size</span>
          <span class="slider-value" id="radiusLabel">250</span>
        </div>
        <input type="range" id="radiusRange" min="50" max="1000" value="250" />
      </div>
    </div>

    <div class="section">
      <div class="slider-container">
        <div class="slider-label-row">
          <span class="label" style="margin: 0;">Zoom</span>
          <span class="slider-value" id="zoomLabel">2.0x</span>
        </div>
        <input type="range" id="zoomRange" min="1.0" max="5.0" step="0.1" value="2.0" />
      </div>
    </div>
  </div>

  <script>
    let img = null;
    let imgLoaded = false;

    let dispW, dispH, offX, offY;
    let radius = 250;
    let zoomFactor = 2.0;
    let currentFilter = 'stipple';
    let animTime = 0;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      background(255);
      setupUI();
      textAlign(CENTER, CENTER);
      fill(0);
      textSize(14);
      textFont('Courier New');
      text('UPLOAD IMAGE', width / 2, height / 2);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      if (imgLoaded) {
        computeDisplayRect();
      }
    }

    function setupUI() {
      const fileInput = document.getElementById('fileInput');
      fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        loadImage(
          url,
          (loaded) => {
            img = loaded;
            img.loadPixels();
            imgLoaded = true;
            computeDisplayRect();
          },
          () => {
            imgLoaded = false;
          }
        );
      });

      const radiusRange = document.getElementById('radiusRange');
      const radiusLabel = document.getElementById('radiusLabel');
      radiusRange.addEventListener('input', (e) => {
        radius = parseInt(e.target.value, 10);
        radiusLabel.textContent = radius;
      });

      const zoomRange = document.getElementById('zoomRange');
      const zoomLabel = document.getElementById('zoomLabel');
      zoomLabel.textContent = '2.0x';
      zoomRange.addEventListener('input', (e) => {
        zoomFactor = parseFloat(e.target.value);
        zoomLabel.textContent = zoomFactor.toFixed(1) + 'x';
      });

      // Filter buttons
      const filterBtns = document.querySelectorAll('.filter-btn');
      filterBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          filterBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentFilter = btn.dataset.filter;
        });
      });
    }

    function computeDisplayRect() {
      if (!img) return;
      const scale = Math.min(width / img.width, height / img.height);
      dispW = img.width * scale;
      dispH = img.height * scale;
      offX = (width - dispW) / 2;
      offY = (height - dispH) / 2;
    }

    function draw() {
      background(255);
      animTime += 0.02; // 더 느리게 (0.05 -> 0.02)

      if (!imgLoaded) {
        fill(0);
        textSize(14);
        textFont('Courier New');
        text('UPLOAD IMAGE', width / 2, height / 2);
        drawCursorCircle();
        return;
      }

      image(img, offX, offY, dispW, dispH);

      push();
      noStroke();
      fill(255);
      drawingContext.save();
      drawingContext.beginPath();
      drawingContext.arc(mouseX, mouseY, radius, 0, Math.PI * 2);
      drawingContext.clip();
      rect(mouseX - radius, mouseY - radius, radius * 2, radius * 2);
      drawingContext.restore();
      pop();

      if (currentFilter === 'stipple') {
        drawStippleFilter();
      } else if (currentFilter === 'sketch') {
        drawSketchFilter();
      } else if (currentFilter === 'dither') {
        drawDitherFilter();
      }

      drawCursorCircle();
    }

    function drawCursorCircle() {
      noFill();
      stroke(0);
      strokeWeight(1);
      ellipse(mouseX, mouseY, radius * 2, radius * 2);
    }

    function getSampleColor(sx, sy) {
      const uCenter = (mouseX - offX) / dispW;
      const vCenter = (mouseY - offY) / dispH;

      if (uCenter < 0 || uCenter > 1 || vCenter < 0 || vCenter > 1) return null;

      const scaleBg = dispW / img.width;
      const lensScreenW = radius * 2;
      const lensScreenH = radius * 2;

      const sourceWidthPx  = lensScreenW  / (zoomFactor * scaleBg);
      const sourceHeightPx = lensScreenH / (zoomFactor * scaleBg);

      const sourceX = uCenter * img.width  - sourceWidthPx  / 2;
      const sourceY = vCenter * img.height - sourceHeightPx / 2;

      const relX = sx / (radius * 2);
      const relY = sy / (radius * 2);
      const imgX = sourceX + (relX + 0.5) * sourceWidthPx;
      const imgY = sourceY + (relY + 0.5) * sourceHeightPx;

      if (imgX < 0 || imgX >= img.width || imgY < 0 || imgY >= img.height) return null;

      const ix = floor(imgX);
      const iy = floor(imgY);
      const idx = (iy * img.width + ix) * 4;

      return {
        r: img.pixels[idx],
        g: img.pixels[idx + 1],
        b: img.pixels[idx + 2],
        gray: (img.pixels[idx] + img.pixels[idx + 1] + img.pixels[idx + 2]) / 3
      };
    }

    function drawStippleFilter() {
      push();
      drawingContext.save();
      drawingContext.beginPath();
      drawingContext.arc(mouseX, mouseY, radius, 0, Math.PI * 2);
      drawingContext.clip();

      noStroke();
      const gridStep = 15;

      for (let sy = -radius; sy <= radius; sy += gridStep) {
        for (let sx = -radius; sx <= radius; sx += gridStep) {
          // 느린 움직임
          const wobbleX = sin(animTime * 1.5 + sx * 0.1) * 2;
          const wobbleY = cos(animTime * 1.5 + sy * 0.1) * 2;
          
          const screenX = mouseX + sx + wobbleX + random(-gridStep * 0.15, gridStep * 0.15);
          const screenY = mouseY + sy + wobbleY + random(-gridStep * 0.15, gridStep * 0.15);
          
          const d = dist(screenX, mouseY + sy, mouseX, mouseY);
          if (d > radius) continue;

          const col = getSampleColor(sx, sy);
          if (!col) continue;

          const darkness = 1.0 - (col.gray / 255.0);
          
          // 크기 범위 줄이기 (더 균일하게)
          const baseDotSize = map(darkness, 0, 1, gridStep * 0.3, gridStep * 1.3);
          
          // 느린 펄스
          const pulse = sin(animTime * 2 + sx * 0.05 + sy * 0.05) * 0.15 + 1;
          const dotSize = baseDotSize * pulse * random(0.9, 1.1);

          fill(0, map(darkness, 0, 1, 180, 255));
          ellipse(screenX, screenY, dotSize, dotSize);
        }
      }

      drawingContext.restore();
      pop();
    }

    function drawSketchFilter() {
      push();
      drawingContext.save();
      drawingContext.beginPath();
      drawingContext.arc(mouseX, mouseY, radius, 0, Math.PI * 2);
      drawingContext.clip();

      stroke(0);
      strokeWeight(1.8);
      const step = 10;

      for (let sy = -radius; sy <= radius; sy += step) {
        for (let sx = -radius; sx <= radius; sx += step) {
          const screenX = mouseX + sx;
          const screenY = mouseY + sy;
          const d = dist(screenX, screenY, mouseX, mouseY);
          if (d > radius) continue;

          const col = getSampleColor(sx, sy);
          if (!col) continue;

          const darkness = 1.0 - (col.gray / 255.0);
          
          const uniqueSeed = sx * 13.7 + sy * 17.3;
          const randomPhase = sin(uniqueSeed) * TWO_PI;
          const randomSpeed = cos(uniqueSeed * 0.7) * 2 + 3;
          
          const pulse = sin(animTime * randomSpeed + randomPhase) * 0.85 + 0.95;
          const lineLen = step * 1.5 * pulse;

          push();
          translate(screenX, screenY);

          if (darkness > 0.15) {
            line(-lineLen/2, 0, lineLen/2, 0);
          }
          if (darkness > 0.4) {
            rotate(PI / 2);
            line(-lineLen/2, 0, lineLen/2, 0);
            rotate(-PI / 2);
          }
          if (darkness > 0.6) {
            rotate(PI / 4);
            line(-lineLen/2, 0, lineLen/2, 0);
            rotate(-PI / 4);
          }
          if (darkness > 0.8) {
            rotate(-PI / 4);
            line(-lineLen/2, 0, lineLen/2, 0);
          }
          
          pop();
        }
      }

      drawingContext.restore();
      pop();
    }

    function drawDitherFilter() {
      push();
      drawingContext.save();
      drawingContext.beginPath();
      drawingContext.arc(mouseX, mouseY, radius, 0, Math.PI * 2);
      drawingContext.clip();

      stroke(0);
      strokeWeight(1);
      fill(255);
      rectMode(CENTER);
      const step = 8;

      for (let sy = -radius; sy <= radius; sy += step) {
        for (let sx = -radius; sx <= radius; sx += step) {
          const screenX = mouseX + sx;
          const screenY = mouseY + sy;
          const d = dist(screenX, screenY, mouseX, mouseY);
          if (d > radius) continue;

          const col = getSampleColor(sx, sy);
          if (!col) continue;

          const darkness = 1.0 - (col.gray / 255.0);
          
          const uniqueSeed = sx * 13.7 + sy * 17.3;
          const randomPhase = sin(uniqueSeed) * TWO_PI;
          const randomSpeed = cos(uniqueSeed * 0.73) * 4 + 5;
          
          const pulse = abs(sin(animTime * randomSpeed + randomPhase));
          const minSize = step * 0.3;
          const maxSize = step * 1.5 * darkness;
          const rectSize = lerp(minSize, maxSize, pulse);

          if (darkness > 0.1) {
            rect(screenX, screenY, rectSize, rectSize);
          }
        }
      }

      rectMode(CORNER);
      drawingContext.restore();
      pop();
    }
  </script>
</body>
</html>